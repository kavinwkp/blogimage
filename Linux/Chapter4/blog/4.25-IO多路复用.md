## IO多路复用

IO多路复用使得程序能同时监听多个文件描述符，能够提高程序的性能，Linux下实现IO多路复用的系统调用主要有select、poll和epoll

**BIO阻塞模型**

缺点：
1. 线程或进程会消耗资源
2. 线程或进程调度消耗CPU资源

**非阻塞，忙轮询**

优点：提高了程序的执行效率
缺点：需要占用更多的CPU和系统资源

**NIO非阻塞模型**

每次循环内O(n)的系统调用

### select

1. 构造一个关于文件描述符的列表，将要监听的文件描述符添加到列表中
2. 调用系统函数，监听该列表中的文件描述符，直到有文件描述符进行IO调用时才返回，阻塞，由内核完成
3. 返回时，会告知进程哪些文件描述符要进行IO操作

```cpp
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
- nfds: 委托内核检测的最大文件描述符的值+1
- readfds: 委托内核检测哪些文件描述符的读的属性，一般检测读操作，接受数据，传入传出参数
- writedfs: 写操作的集合，是否还有缓冲区可以写数据
- exceptfds: 检测异常
- timeout: 设置的超时时间
    - NULL: 永久阻塞，直到文件描述符有变化
struct timeval {
    long    tv_sec;         /* seconds */
    long    tv_usec;        /* microseconds */
};
// 成功返回检测的集合中发生变化的文件描述符数量，失败返回-1
---
void FD_CLR(int fd, fd_set *set);
// 将文件描述符对应的标志位置1
---
int  FD_ISSET(int fd, fd_set *set);
// 判断某个fd是0还是1
---
void FD_SET(int fd, fd_set *set);
// 设置某个fd为标志位为1
---
void FD_ZERO(fd_set *set);
// fd集合全部初始化为0
```




