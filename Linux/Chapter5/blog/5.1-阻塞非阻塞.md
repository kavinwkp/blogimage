## 阻塞/非阻塞（网络IO）

>+ 一个典型的网络IO接口调用，分为两个阶段，分别是“数据就绪”和“数据读写”，数据就绪阶段分为阻塞和非阻塞，表现的结果就是，阻塞当前线程还是直接返回
>+ 同步表示A向B请求调用一个网络IO接口时，数据的读写都是由请求方自己来完成的（不管是阻塞还是非阻塞）；
>+ 异步表示A向B请求调用一个接口时，向B传入请求的事件以及事件发生时的通知方式，A就可以去处理其他逻辑了，当B监听到事件处理完成后，就用事先约定好的通知方式，通知A处理结果

网络IO包括2个阶段
1. 数据就绪
2. 数据读写

**数据就绪**

+ 阻塞：调用IO方法的线程会进入阻塞状态，会被挂起
+ 非阻塞：不会改变线程状态，通过返回值判断
```cpp
int len = recv(sockfd, buf, 1024, 0);
// 通过recv的返回值来判断，非阻塞
len = -1: 出错（EINTR/EAGAIN要特殊判断）
len = 0: 读取到数据末尾，对方连接关闭
len > 0: 读取到的数据大小
```

## 同步/异步（网络IO）

**数据读写**

+ 同步

数据放在TCP接收缓冲区，需要用户调用`recv`去读取
需要等`recv`数据接收完成，才能继续执行后面判断的代码

+ 异步

需要有通知方式，调用异步接口后就可以继续执行后面的代码，内核把数据放到buf里面后会通知应用程序

Linux中的异步接口：`aio_read/aio_write`


## 5种IO模型

1、阻塞blocking

调用者调用了某个函数,等待这个函数返回,期间什么也不做,不停的去检查这个函数有没有返回,必
须等这个函数返回才能进行下一步动作

2、非阻塞non-blocking

非阻塞等待,每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I/O执行系统调
用总是立即返回,不管事件是否已经发生,若事件没有发生,则返回-1,此时可以根据 errno 区分这两
种情况,对于`accept`,`recv` 和 `send`,事件未发生时,`errno` 通常被设置成 EAGAIN

3、IO复用multiplexing

Linux 用 `select/poll/epoll` 函数实现 IO 复用模型,这些函数也会使进程阻塞,但是和阻塞IO所不同的是
这些函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。直到有数
据可读或可写时,才真正调用IO操作函数

4、信号驱动signal-driven

Linux 用套接口进行信号驱动 IO,安装一个信号处理函数,进程继续运行并不阻塞
当IO事件就绪,进程收到SIGIO 信号,然后处理 IO 事件
内核在第一个阶段是异步,在第二个阶段是同步;与非阻塞IO的区别在于它提供了消息通知机制
不需要用户进程不断的轮询检查,减少了系统API的调用次数,提高了效率

5、异步IO(asynchronous)

Linux中,可以调用`aio_read`函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式,然后立即返回,当内核将数据拷贝到缓冲区后,再通知应用程序